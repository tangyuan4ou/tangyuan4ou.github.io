{"meta":{"title":"TangYuan","subtitle":null,"description":null,"author":"TangYuan","url":"http://yoursite.com"},"pages":[{"title":"","date":"un55fin55","updated":"un55fin55","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"tangyuan Home about archives contact Hi friend 2013年 我来到哈尔滨理工大学 就读软件工程专业 从那一年我被迫学习编程 忧郁 因为我觉得我喜欢美术，也学了6年 从幼稚园开始我无数次幻想未来卧坐在宽大的办公室绘制绚丽的设计稿 但是所有美术老师都说我没有天赋 我放弃艺术选择理科 但是并没有放弃当初的愿望 考进理工大学想要学习工业设计 我觉得我宽大办公座要来了 但是 我被调剂到了一个陌生的领域 头两年我几乎放弃学习，翘课，挂科，无限的放纵自己 在开始大三的时候终于意识我马上要毕业了 要失业了 我不能一直啃老 要对未来负责 从ui到产品，从入门到放弃 我渐渐意识到其实我并不喜欢设计，我喜欢的其实是实现 冥冥之中命运安排我和程序见面 我开始学习前端 我知道我想要的是什么了 我好像具备很多程序员的特征，死宅，不喜欢社交，喜欢较真 唯一不相配的应该就是我是一个女生吧 呵呵 2016年 我在厦门联合优创科技有限公司实习 开始了解公司开发项目的流程 视野也开始变开阔了 2017年 毕业季 我孤身一人来到北京 目前在新东方工作 虽然现在我并不优秀 但是 我相信只有喜欢自己的工作未来才会不断进步 我可以很肯定的说我很喜欢前端 未来 谁又知道呢 呵呵 我相信我可以 以上 感谢阅读 祝好 座右铭 不该在吃苦的年纪享受安逸 ©2017-未来&nbsp;♥&nbsp;tangyuan 📪 //获取页面p的数量，在about.js编写报错，有待测试 var length = $('p').length; var arr = []; for(var i=0; i"},{"title":"","date":"un55fin55","updated":"un55fin55","comments":true,"path":"contact/index.html","permalink":"http://yoursite.com/contact/index.html","excerpt":"","text":"Home about archives contact Hi friend &nbsp;&nbsp;&nbsp;&nbsp;本页依然是添加了disqus的评论，所以仍然需要翻墙 这次没有设置弹窗，如果您不翻墙评论框是不会刷新出来的 如果翻墙了但是没有显示评论框，那么请刷新页面 如果您对我编写的网站感兴趣，欢迎给我留言，大家一起学习成长✌ 如果您不方便翻墙可以单击底导的邮箱icon给我发邮件👇 (function() { var d = document, s = d.createElement('script'); s.src = 'https://https-tangyuan4ou-github-io.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); ©2017-未来&nbsp;♥&nbsp;tangyuan 📪 var height = window.screen.availHeight; var left = ($('body').width() - 1200) / 2; if( $('body').height() < height - 30 ) { $('body').css('height', height - 30); } $('.contactContainer').css('margin-left', left); $('.searchList').css('right', 115 + left); $(window).scroll(function(){ var wst = $(window).scrollTop(); if ( wst == 0 ) { $('.menu-section').removeClass('menu-section-animation'); $('.searchList').css('right', 115 + left); } else { $('.menu-section').addClass('menu-section-animation'); $('.searchList').css('right', 115); } }) $('.menu-toggle').click(function(){ $('.menu-section').toggleClass('menu-section-black'); })"},{"title":"","date":"un55fin55","updated":"un55fin55","comments":true,"path":"contact/css/style.css","permalink":"http://yoursite.com/contact/css/style.css","excerpt":"","text":"body { width: 100%; position: relative; background: #161823; } .menu-section { position: fixed; top: 10px; left: 50%; width: 1200px; opacity: 1; border-radius: 6px; transform: translateX(-50%); -moz-transform: translateX(-50%); -webkit-transform: translateX(-50%); } .menu-section-black { background: #cccccc; } .menu-section-animation { width: 100%; opacity: 0.5; margin-top: 0; border-radius: 0; top: 0; animation: menuSectionAnimation 0.5s ease; -moz-animation: menuSectionAnimation 0.5s ease; -webkit-animation: menuSectionAnimation 0.5s ease; } @keyframes menuSectionAnimation { 0%{ top: 10px; width: 1200px; opacity: 1; } 100%{ top: 0; width: 100%; opacity: 0.5; } } .searchList { position: fixed; top: 45px; } .contactContainer { padding-top: 80px; padding-bottom: 20px; color: #cccccc; } .contact p { margin: 0; } #disqus_thread { background: #e9f1f6; width: 1200px; margin: 0 auto; border-radius: 6px; padding: 0 10px; box-shadow: 3px -3px 5px #85918f; } .footer { position: absolute; bottom: 0; left: 0; width: 100%; height: 100px; text-align: center; line-height: 100px; color: #cccccc; font-size: 14px; background: #161823; } .footer a { text-decoration: none; cursor: pointer; } .nav .searchBtn, .search{ background: #cccccc; }"},{"title":"","date":"un55fin55","updated":"un55fin55","comments":true,"path":"about/css/style.css","permalink":"http://yoursite.com/about/css/style.css","excerpt":"","text":"body { background: #161823; } .aboutContainer { position: relative; width: 1050px; margin: 100px auto 0; background: #161823; } .aT,.aR,.aB,.aL { width: 100%; height: 100%; position: absolute; } .aT { width: 0; border-top: 1px solid rgb(233, 241, 246); animation: tA 1s ease 1s forwards; -moz-animation: tA 1s ease 1s forwards; -webkit-animation: tA 1s ease 1s forwards; } .aR { height: 0; border-right: 1px solid rgb(233, 241, 246); animation: rA 1s ease 1s forwards; -moz-animation: rA 1s ease 1s forwards; -webkit-animation: rA 1s ease 1s forwards; } .aB { left: 953px; width: 0; border-bottom: 1px solid rgb(233, 241, 246); animation: bA 1s ease 1s forwards; -moz-animation: bA 1s ease 1s forwards; -webkit-animation: bA 1s ease 1s forwards; } .aL { height: 0; top: 100%; border-left: 1px solid rgb(233, 241, 246); animation: lA 1s ease 1s forwards; -moz-animation: lA 1s ease 1s forwards; -webkit-animation: lA 1s ease 1s forwards; } @keyframes tA { to { width: 100%; } } @keyframes rA { to { height: 100%; } } @keyframes bA { to { left: 0; width: 100%; } } @keyframes lA { to { top: 0; height: 100% } } .svg { margin: 50px 30px; } .draw { stroke-dasharray: 1310; stroke-dashoffset: 1310; fill: #161823; transition: fill 2s ease; -moz-transition: fill 2s ease; -webkit-transition: fill 2s ease; animation: draw 6s ease 2s forwards; -moz-animation: draw 6s ease 2s forwards; -webkit-animation: draw 6s ease 2s forwards; } @keyframes draw { to{ stroke-dashoffset: 0; } } .fill { stroke-dasharray: 1310; /*定义描边的虚线长度，如果提供奇数个，则会自动复制该值成偶数*/ stroke-dashoffset: 1310; /*定义虚线描边的偏移量（在路径开始的前面，看不到）*/ animation: fill 5s ease 2s forwards; -moz-animation: fill 5s ease 2s forwards; -webkit-animation: fill 5s ease 2s forwards; } @keyframes fill { to { stroke-dashoffset: 0; fill: #161823; } } .aboutContainer .content{ width: 1010px; padding: 50px 20px 50px; background: rgb(233, 241, 246); opacity: 0; transition: opacity 2s ease 2s; -moz-transition: opacity 2s ease 2s; -webkit-transition: opacity 2s ease 2s; } .headerImg { width: 200px; opacity: 0; margin: -35px auto 0; } .imgAnimate { animation: iA 2s ease forwards; -moz-animation: iA 2s ease forwards; -webkit-animation: iA 2s ease forwards; } @keyframes iA { to { margin-top: 0px; opacity: 1; } } .img { width: 100%; } .aboutContainer .content p { width: 100%; height: 18px; text-align: center; font-size: 16px; color: #606060; line-height: 5px; opacity: 0; } .pAnimate { animation: pA 1s ease forwards; -moz-animation: pA 1s ease forwards; -webkit-animation: pA 1s ease forwards; } @keyframes pA { to { opacity: 1; line-height: 18px; } } .aboutContainer .content .year { margin: 30px 0; font-size: 14px; color: #9B989F; }"},{"title":"","date":"un55fin55","updated":"un55fin55","comments":true,"path":"about/js/about.js","permalink":"http://yoursite.com/about/js/about.js","excerpt":"","text":"(function(){ /* 调整archive页nav样式 */ //菜单按钮 $('.menu-section').css('position', 'absolute'); $('.name').text('tangyuan').css('color', '#ffffff'); $('.navBtn').css('background-color', '#ffffff'); //search $('.search').css({'background':'#161823', 'color': '#ffffff', 'border-color':'#ffffff'}); $('.searchBtn').css({'background':'none', 'color': '#ffffff'}); //svg动画，文章背景填充颜色 setTimeout(function(){ $('.draw').css('fill', 'rgb(233, 241, 246)'); $('.content').css('opacity', 1); }, 4000); //根据浏览器滚动加载文字 var height = window.innerHeight - 150; $(window).scroll(function(){ var wst = $(window).scrollTop(); //p动画 for (var j in arr) { if ( parseInt(arr[j].offset().top)-height < wst ){ arr[j].addClass('pAnimate'); } } //img动画 if (parseInt($('.headerImg').offset().top)-650 < wst) { $('.headerImg').addClass('imgAnimate'); } }) })();"}],"posts":[{"title":"react笔记（二）","slug":"react笔记-二","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2017/11/16/react笔记-二/","link":"","permalink":"http://yoursite.com/2017/11/16/react笔记-二/","excerpt":"","text":"&nbsp;&nbsp;&nbsp;&nbsp;这部分是关于react props，state和ref的整理 props和state都可以用来传递数据： props&nbsp;&nbsp;&nbsp;&nbsp;props只读性，官方说法是：无论是使用函数或者类来声明一个组件，它绝对不能修改它自己的props。 props传参方式：class Tangyuan extends React.Component { render() { return ( &lt;div&gt;hello, {this.props.name}&lt;/div&gt; ) } } class Youyou extends React.Component { render() { return ( &lt;Tangyuan name=&quot;tangyuan&quot; /&gt; ) } } ReactDOM.render( &lt;Youyou /&gt;, document.getElementById(&#39;root&#39;) ); state&nbsp;&nbsp;&nbsp;&nbsp;state可以根据交互来改变，这就是为什么有一些容器组件需要定义state来更新和修改数据，而子组件只能通过props来传递数据。 statefunction FormattedDate(props) { return &lt;h2&gt;It is {props.date.toLocaleTimeString()}.&lt;/h2&gt;; } class Clock extends React.Component { constructor(props) { super(props); this.state = {date: new Date()}; } componentDidMount() { this.timerID = setInterval( () =&gt; this.tick(), 1000 ); } componentWillUnmount() { clearInterval(this.timerID); } tick() { this.setState({ date: new Date() }); } render() { return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;FormattedDate date={this.state.date} /&gt; &lt;/div&gt; ); } } function App() { return ( &lt;div&gt; &lt;Clock /&gt; &lt;Clock /&gt; &lt;Clock /&gt; &lt;/div&gt; ); } ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;)); refsrefs的使用情况： · 处理焦点、文本选择或媒体控制。 · 触发强制动画 · 集成第三方DOM库 &nbsp;&nbsp;&nbsp;&nbsp;如果可以通过声明实现，则尽量避免使用refs 不要过度使用refs&nbsp;&nbsp;&nbsp;&nbsp;多在组件中使用state，因为较高级别的state更清晰。 添加方式： refsclass CustomTextInput extends React.Component { constructor(props) { super(props); this.focus = this.focus.bind(this); } focus() { // 直接使用原生 API 使 text 输入框获得焦点 this.textInput.focus(); } render() { // 使用 &#39;ref&#39; 的回调将 text 输入框的 DOM 节点存储到 React // 实例上（比如 this.textInput） return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref={(input) =&gt; { this.textInput = input; }} /&gt; &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick={this.focus} /&gt; &lt;/div&gt; ); } } 还有可以： refsthis.refs.yourRefname.你的操作 //获取 &lt;div ref=&quot;yourRefname&quot;&gt;&lt;/div&gt; //设置 &nbsp;&nbsp;&nbsp;&nbsp;以上就是我对react的我常用且容易混淆的知识点的总结。","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react笔记（一）","slug":"react笔记（一）","date":"un33fin33","updated":"un33fin33","comments":true,"path":"2017/11/15/react笔记（一）/","link":"","permalink":"http://yoursite.com/2017/11/15/react笔记（一）/","excerpt":"","text":"&nbsp;&nbsp;&nbsp;&nbsp;去年用react跟公司开发了一个项目，一直都是师傅带着我，项目是做好了，但是react这还是一直似懂非懂的，前段时间自己编写了一个hexo的主题，用react仿写了一下主题，没写完，但是还是决定抽时间总结一下。 组件化&nbsp;&nbsp;&nbsp;&nbsp;提到react不得不提到组件化，组件化是react的特性之一，这也是也它风靡一时的原因之一。随着前端的发展，模块化，组件化已经成为一种趋势，它通过拆分dom使开发人员开发和维护网站更便利。 关于react&nbsp;&nbsp;&nbsp;&nbsp;react是facebook开发的开源前端框架，主要针对view层、最近由于和苹果的问题，国内公司陆续中断了关于react的使用，但是我觉得react还是值得一学的，不论生命周期还是props、stste、refs。 &nbsp;&nbsp;&nbsp;&nbsp;写这个是为了回顾和总结一下最近学习的知识，笔记。 入门&nbsp;&nbsp;&nbsp;&nbsp;提笔的时候发现入门有啥，尴尬😅，翻一翻react中文／react英文文档，天，这是什么，我就半年没有看竟然变成了这样，快速入门不再是当初的简单的几个数据的传递，变成了一个游戏,看来我确实荒废太久了。教程和文档写的非常详细，入门很适合看一下。 生命周期&nbsp;&nbsp;&nbsp;&nbsp;React.Component是一个抽象基础类，因此直接引用React.Component几乎没有意义。相反，你通常会继承他，并且至少定义个一render()方法。 Component()class Greeting extends Component { render() { return &lt;h1&gt;Hello, Tangyuna&lt;/h1&gt;; } } &nbsp;&nbsp;&nbsp;&nbsp;若你仍未使用 ES6，你可以使用 create-react-class模块。 组件的生命周期分为几个阶段： 装配&nbsp;&nbsp;&nbsp;&nbsp;在组件实例被创建和插入DOM时被调用 · constructor() &nbsp;&nbsp;&nbsp;&nbsp;组件的构造函数将会在装配之前调用 constructor()constructor(props) { super(props) this.state = { color: props.tangyuan } this.handleClick = this.handleClick.bind(this) } · conponentWillMount() &nbsp;&nbsp;&nbsp;&nbsp;装配发生之前调用。也就是说在render之前调用，在这里设置状态是不会出发重渲的，避免在该方法中引入任何的副作用和订阅。 &nbsp;&nbsp;&nbsp;&nbsp;这是唯一会在服务端渲染调起的生命周期钩子函数，通常推荐使用constructor() · render() · componentDidMount() &nbsp;&nbsp;&nbsp;&nbsp;在组建装配之后立即调用，初始化使DOM节点应该进行到这里，若需要从远端加载数据，这是一个很适合实现网络请求的地方，可设置状态出发重渲。 更新&nbsp;&nbsp;&nbsp;&nbsp;组件状态更新重新渲染，触发更新。调用一下方法。 · componentWillReceiveProps(nextProps) &nbsp;&nbsp;&nbsp;&nbsp;当组件传入props发生变化时调用，例如： 父组件状态改变，给予组件传入新的props值，用于组件peops变化后，更新state · shouldComponentUpdate() &nbsp;&nbsp;&nbsp;&nbsp;我接触这个框架的时候react已经在中国大量下架了。所以我也没有深学所有的内容，这部分我也只是了解。 &nbsp;&nbsp;&nbsp;&nbsp;看过一些文章对这个方法的评价是，可提高性能，但是表现是微乎其微，并且隐藏bug会比较多，但是我并没有测试过。 &nbsp;&nbsp;&nbsp;&nbsp;编写这点需要使用不可变的状态，immutable.js或者Object.assign都可以。 · componentWillUpdate(nextProps, nextState) &nbsp;&nbsp;&nbsp;&nbsp;当props和state发生变化的时候执行，在render之前，初始化render的时候不执行，在这里不能使用this.props和this.state。 &nbsp;&nbsp;&nbsp;&nbsp;函数调用以后nextProps和nextState会被设置到this.props和this.state中，然后调用render方法更新洁面 · render() · componentDidUpdate(prevProps, prevState) &nbsp;&nbsp;&nbsp;&nbsp;组件更新结束之后执行，在初始化render时不执行 卸载&nbsp;&nbsp;&nbsp;&nbsp;当组件从DOM中移除的时候调用 · componentWillUnmount() &nbsp;&nbsp;&nbsp;&nbsp;当组件要被从界面上移除的时候，就会调用componentWillUnmount(),在这个函数中，可以做一些组件相关的清理工作，例如取消计时器、网络请求等。 其他api · setState() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置state，属性值接受函数字符串和数值。 · forceUpdate() forceUpdate()this.state.valueWantChange = vale; this.forceUpdate(); // this.setState(this.state); &nbsp;&nbsp;&nbsp;&nbsp;在以下两种情况会用到 forceUpdate &nbsp;&nbsp;&nbsp;&nbsp;· 手动更改了 state &nbsp;&nbsp;&nbsp;&nbsp;·之后需要触发 render &nbsp;&nbsp;&nbsp;&nbsp;做了除更改props和state之外的操作后，需要render。 &nbsp;&nbsp;&nbsp;&nbsp;但是使用forceUpdate 会跳过 shouldComponentUpdate 的过程，会触发子组件的所有lifeCycle方法（包括shouldComponentUpdate）从而造成性能的浪费。因此为了组件更加清晰高效，应该避免使用forceUpdate。 类属性 · defaultProps &nbsp;&nbsp;&nbsp;&nbsp;默认属性 defaultPropsclass Tangyuan extends React.Component { // ... } Tangyuan.defaultProps = { color: &#39;yellow&#39; }; · displayName &nbsp;&nbsp;&nbsp;&nbsp;displayName被用在调试信息中。JSX会自动设置该值 实例属性 · props · state 总结以上是我关于react生命周期的总结，既是总结也是笔记。方便日后翻阅，没有教学的功能。 后面会写一下关于props、state和ref的总结。","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"波折的两个月","slug":"波折的两个月","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2017/11/09/波折的两个月/","link":"","permalink":"http://yoursite.com/2017/11/09/波折的两个月/","excerpt":"","text":"&nbsp;&nbsp;&nbsp;&nbsp;最近也不知道自己在干些啥，博客网站写好了我就开始陷入了空窗期，公司陆陆续续的任务我也无心学习和更新。 &nbsp;&nbsp;&nbsp;&nbsp;中间我一度反省自己改学习了。翻出去年学的react代码，天，这是什么，是时候学习巩固react了，我决定翻写这个网站，断断续续写了半个月，写不动了，哎，没有数据，我是不是该学学后端语言了，学无止境啊。 &nbsp;&nbsp;&nbsp;&nbsp;搞搞redux，半个月我跳槽了😂，新公司忙着弄vue，那个react的hexo被我再次被我无限搁置，我亲爱的mac又被我水洗了，想想有俩月没写过博客了，我也不知道我在做些什么。 &nbsp;&nbsp;&nbsp;&nbsp;深恶痛绝，治好mac，打开项目，我决定痛改前非，定期总结，养成良好的整理习惯。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"关于面向对象编程思想的理解","slug":"oop","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2017/09/07/oop/","link":"","permalink":"http://yoursite.com/2017/09/07/oop/","excerpt":"","text":"面向对象&nbsp;&nbsp;&nbsp;&nbsp;面向对象的思想主要以对象为主，将一个问题抽象成一个具体的对象，并将抽象出来的对象和对象的属性和方法封装成一个类。 &nbsp;&nbsp;&nbsp;&nbsp;面向对象是把构成问题的事物分解成对象，建立对象的目的不是为了要完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为。 &nbsp;&nbsp;&nbsp;&nbsp;实例化：在面向对象的编程中，通常把用类创建对象的过程叫做实例化 面向对象与面向过程的区别&nbsp;&nbsp;&nbsp;&nbsp;面向对象以名词为主，将问题抽象成具体的对象，在解决问题的时候将不同对象组合在一起。 &nbsp;&nbsp;&nbsp;&nbsp;面向过程以动词为主，主要是分析问题的解决步骤，将问题一步步实现后拼接在一起。 &nbsp;&nbsp;&nbsp;&nbsp;有一个比喻很出名也很有意思： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;面向对象：狗.吃(屎) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;面向过程：吃.(狗， 屎) 面向对象两种表达方式&nbsp;&nbsp;&nbsp;&nbsp;面向对象有两种表达方式，基于类的面向对象和基于原型的面向对象。在基于类的面向对象方式中，对象依靠类来产生。而在基于原型的面向对象方式中，对象则是依靠构造器利用原型构造出来的。 &nbsp;&nbsp;&nbsp;&nbsp;关于这两种哪个更彻底的表达了面向对象的思想目前尚有争论。我也就不发表意见了。 关于对象的上下文依赖（我在别的文章看到的，忘了出处了）var str = &quot;我是String对象的声明&quot; var obj = { des: &quot;我是obj对象的声明&quot; } var fun = function () { console.log(&quot;我是函数对象，目前属于：&quot;， this) }; obj.fun = fun; console.log( this === window ); //true console.log( window.str === str ); //true console.log( window.obj === obj ); //true console.log( window.fun === fun ); //true fun(); //我是函数对象，目前属于：wimdow obj.fun(); //我是一个函数对象，目前属于：obj fun.apply(str); //我是一个函数对象，目前属于：str","categories":[],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://yoursite.com/tags/OOP/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"关于Hexo主题的制作","slug":"hexo","date":"un11fin11","updated":"un44fin44","comments":true,"path":"2017/08/28/hexo/","link":"","permalink":"http://yoursite.com/2017/08/28/hexo/","excerpt":"","text":"关于Hexo和Hexo的安装&nbsp;&nbsp;&nbsp;&nbsp;关于Hexo我就不做详细的介绍了。现在，简单说一下安装。 &nbsp;&nbsp;&nbsp;&nbsp;hexo官网上讲mac和w的安装不同，并且max要基于xCode，但是本人换mac电脑后在搭环境的时候并没有使用xCode，目前没有发现问题。（因为我本人觉得xCode难用😂，可能我段位不行吧） &nbsp;&nbsp;&nbsp;&nbsp;安装很简单，按照Hexo文档一步步来就可以了，有一个问题是在挂载到gitHub上的时候.yml配置文件要加空格。 从零开始编写Hexo主题新建主题&nbsp;&nbsp;&nbsp;&nbsp;关于编写主题呢，我是在Hexo的默认主题里编写的，在themes新建文件夹，修改配置文件，改为你新建文件夹的名字。 ./_config.ymltheme: 名字随意，但是和themes下新建文件夹名字相同 编写主题&nbsp;&nbsp;&nbsp;&nbsp;先讲一我的下Hexo的目录结构： ./themesyourThems ├──langusges 语言文件，用于国际化 ├──layout 页面模板文件 ├──scripts Hexo 脚本 ├──source 主题资源文件，包括页面样式，脚本，字体等 1.languages: &nbsp;&nbsp;&nbsp;&nbsp;一般主题下有一个languages文件夹，用于对应language配置项，比如在ejs中有： &nbsp;&nbsp;&nbsp;&nbsp;&lt;%= __(‘paginator’) %&gt; &nbsp;&nbsp;&nbsp;&nbsp;language的配置项的是 zh-CN ，则会在languages文件夹下找到zh-CN.yml文件中对应的项来解释 2.layout: &nbsp;&nbsp;&nbsp;&nbsp;网站的页面部分，使用Hexo的模版的语言ejs，可以先翻阅一下ejs的规范 3.source: &nbsp;&nbsp;&nbsp;&nbsp;主要存放css/js/img等资源文件. &nbsp;&nbsp;&nbsp;&nbsp;在Hexo新建项目时会安装hexo-render-stylus这个插件，所以无需其他步骤，只需要将样式文件放到css文件夹中css文件夹中。Hexo在生成页面的时候会将source中的所有文件复制到生成的public文件夹中，并且在此之前会编译styl为css文件。 &nbsp;&nbsp;&nbsp;&nbsp;在css文件夹中创建style.styl，编写一些基础样式，并把所有样式import到这个文件夹。所以最终编译之后只会有style.css一个文件夹。 &nbsp;&nbsp;&nbsp;&nbsp;我在网页中引用阿里icon了，所以我把字体文件也放到这个文件夹了。 添加页面新建页面的命令是hexo n page ‘页面名称’ &nbsp;&nbsp;&nbsp;&nbsp;创建页面后页面会在source目录下新建文件夹，有一个.md的入口文件，可以在文件夹下加入css／js等文件夹，但是有一个问题是当前目录下的页面想要访问public下资源文件时不能使用本地路径，使用: css线上使用： &lt;link href=&quot;https://yourName.github.io/css/style.css&quot; rel=&quot;stylesheet&quot;&gt; 调试可以使用： &lt;link href=&quot;http//localhost:4000/css/style.css&quot; rel=&quot;stylesheet&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;js和img同理 添加目录&nbsp;&nbsp;&nbsp;&nbsp;在要添加目录的页面中加入下面的代码，我是在post页添加的 post.ejstoc(post.content) 或 toc(page.content, {list_number: true}) //是否显示列表数字 &nbsp;&nbsp;&nbsp;&nbsp;最后在编写文章的时候添加 toc: true字段就可以了。 添加留言板&nbsp;&nbsp;&nbsp;&nbsp;这部分我使用的是disqus插件，可以去它的官网注册一个账号。把它的js代码放到自己的代码中就可以了。 &nbsp;&nbsp;&nbsp;&nbsp;但是有一个问题是它被墙了，得翻墙才能使用，谁让它不用输入备案号呢，多说也死了，如果你的网站有备案号并且不想跨域的话也可以使用畅言。据说可以随便输个备案号就能用，我没试过不好使可别过来评论骂我啊。 添加站内搜索&nbsp;&nbsp;&nbsp;&nbsp;我下载的hexo-generator-json-content插件会生成content.json文件，直接发ajax就好了。 &nbsp;&nbsp;&nbsp;&nbsp;还有一个插件hexo-generator-search会生成search.xml文件。 &nbsp;&nbsp;&nbsp;&nbsp;也可以使用Swiftype、 微搜索、Local Search 和 Algolia,Swiftype和Algolia等插件，据说有的有试用期，我觉得工程量不大，所以我没调用，所以好不好用我也不知道。大家自行感悟吧。 Hexo的命令Hexo的常见命令有： &nbsp;&nbsp;&nbsp;&nbsp;hexo n == hexo new ‘’&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新建博客或者页面 新建页面是hexo n page ‘’ &nbsp;&nbsp;&nbsp;&nbsp;hexo g == hexo generate&nbsp;&nbsp;&nbsp;&nbsp;将文件打包到静态文件public下 &nbsp;&nbsp;&nbsp;&nbsp;hexo c == hexo clean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;清空public文件夹下的内容 &nbsp;&nbsp;&nbsp;&nbsp;hexo s == hexo server&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本地运行代码，默认端口4000 &nbsp;&nbsp;&nbsp;&nbsp;hexo d == hexo deploy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将public的内容提交到远端 还有一些命令帮助： &nbsp;&nbsp;&nbsp;&nbsp;1、help：查看帮助信息 &nbsp;&nbsp;&nbsp;&nbsp;2、init[文件夹名]：创建一个hexo项目，不指定文件夹名则在当前目录创建 &nbsp;&nbsp;&nbsp;&nbsp;3、version：查看hexo的版本 &nbsp;&nbsp;&nbsp;&nbsp;4、–config config-path：指定配置文件，代替默认的_config.yml &nbsp;&nbsp;&nbsp;&nbsp;5、–cwd cwd-path：指定当前工作目录 &nbsp;&nbsp;&nbsp;&nbsp;6、–debug：调试模式，输出所有日志信息 &nbsp;&nbsp;&nbsp;&nbsp;7、–safe：安全模式，禁用所有插件和脚本 &nbsp;&nbsp;&nbsp;&nbsp;8、–silent：无日志输出模式 我一般的命令习惯是： &nbsp;&nbsp;&nbsp;&nbsp;hexo s –debug &nbsp;&nbsp;&nbsp;&nbsp;hexo c &nbsp;&nbsp;&nbsp;&nbsp;hexo g &nbsp;&nbsp;&nbsp;&nbsp;hexo d 编写文章&nbsp;&nbsp;&nbsp;&nbsp;可以翻阅一下Markdown的文档。基于它的规范编写就可以了 总结&nbsp;&nbsp;&nbsp;&nbsp;以上就是我编写hexo的全部心得了，虽然写的不是特别详细但是我觉得也足够用了。 &nbsp;&nbsp;&nbsp;&nbsp;从开始决定写博客到实现用了半年的时间，之前很懒，直接用react+webpack写了一版打包直接就扔到public文件夹下了，连ejs都没有用，所以问题很多也并没有实现，后来开始毕设就无限搁置了，直到7月31日我正式入职新东方，电脑也换新的，我收起躁动的心，重新搭环境，按照hexo的规范编写了这个主题，从搭环境到编写主题，中间还有对网站的设计一共用了3周，因为是边学边写，可能很多地方都不是很完美，在未来我会一步步完善的。 &nbsp;&nbsp;&nbsp;&nbsp;欢迎大家提意见。你们的意见是我学习的动力😄。 以上 祝好","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]}